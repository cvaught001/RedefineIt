<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Canvas Fern — Trig + Growth + Outline Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0b0f13;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      .ui {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 2;
        font: 14px/1.35 system-ui, sans-serif;
        color: #d8f5df;
        background: rgba(10, 15, 20, 0.55);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(140, 200, 160, 0.25);
        border-radius: 12px;
        padding: 12px;
        width: 300px;
        max-height: 92vh;
        overflow: auto;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
      }
      .row label {
        flex: 1 1 auto;
      }
      .row input[type='range'] {
        width: 120px;
      }
      .row input[type='color'] {
        width: 40px;
        height: 24px;
        padding: 0;
        border: none;
        background: transparent;
      }
      .btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid rgba(150, 220, 180, 0.3);
        background: rgba(12, 20, 16, 0.6);
        color: #d8f5df;
        cursor: pointer;
      }
      .btn:active {
        transform: translateY(1px);
      }
      small {
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <div class="ui">
      <strong style="display: block; margin-bottom: 6px">Fern Controls</strong>

      <div class="row">
        <label>Leaflets <small id="leafletCountVal"></small></label
        ><input id="leafletCount" type="range" min="16" max="64" value="36" />
      </div>
      <div class="row">
        <label>Base Angle (°) <small id="baseAngleVal"></small></label
        ><input id="baseAngle" type="range" min="10" max="58" value="34" />
      </div>
      <div class="row">
        <label>Stem Curvature <small id="curvVal"></small></label
        ><input id="curv" type="range" min="0" max="100" value="36" />
      </div>
      <div class="row">
        <label>Leaflet Bend <small id="bendVal"></small></label
        ><input id="bend" type="range" min="0" max="100" value="28" />
      </div>
      <div class="row">
        <label>Taper Power <small id="taperVal"></small></label
        ><input id="taper" type="range" min="60" max="200" value="110" />
      </div>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: outline controls -->
      <div class="row">
        <label>Outline Width (px) <small id="olwVal"></small></label>
        <input id="olw" type="range" min="0" max="4" step="0.1" value="1" />
      </div>
      <div class="row">
        <label>Outline Color</label>
        <input id="olc" type="color" value="#00ff66" />
      </div>
      <div class="row">
        <label>Fill Opacity <small id="fillVal"></small></label>
        <input id="fill" type="range" min="0" max="100" value="55" />
      </div>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: growth controls -->
      <div class="row">
        <label>Variety</label>
        <select id="variety" class="sel">
          <option value="custom">Custom</option>
          <option value="bracken">Bracken</option>
          <option value="maidenhair">Maidenhair</option>
          <option value="boston">Boston</option>
          <option value="staghorn">Staghorn</option>
          <option value="ostrich">Ostrich</option>
        </select>
      </div>

      <div class="row">
        <label>Transparent BG</label>
        <input id="transparentBg" type="checkbox" />
      </div>

      <div class="row">
        <label>Perspective</label>
        <input id="perspOn" type="checkbox" />
      </div>
      <div class="row">
        <label>Foreshortening <small id="perspVal"></small></label>
        <input id="persp" type="range" min="0" max="100" value="40" />
      </div>

      <div class="row">
        <button id="toggleGrow" class="btn">▶ Grow</button>
        <button id="resetGrow" class="btn">⟲ Reset</button>
      </div>
      <div class="row">
        <label>Growth Speed <small id="gsVal"></small></label>
        <input id="gs" type="range" min="5" max="100" value="28" />
      </div>
      <div class="row">
        <label>Growth (manual) <small id="gVal"></small></label>
        <input id="g" type="range" min="0" max="100" value="100" />
      </div>
      <small>Tip: Press <b>G</b> to toggle growth animation.</small>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: complexity controls -->
      <div class="row">
        <label>Serration Freq</label>
        <input id="serrFreq" type="range" min="0" max="6" step="0.1" value="3" />
      </div>
      <div class="row">
        <label>Serration Amp (%)</label>
        <input id="serrAmp" type="range" min="0" max="60" step="1" value="18" />
      </div>
      <div class="row">
        <label>Pinnules</label>
        <input id="pinnulesOn" type="checkbox" />
      </div>
      <div class="row">
        <label>Pinnule Count</label>
        <input id="pinCount" type="range" min="0" max="18" value="8" />
      </div>
      <div class="row">
        <label>Pinnule Scale (%)</label>
        <input id="pinScale" type="range" min="10" max="50" value="28" />
      </div>
      <div class="row">
        <label>Pinnule Angle (°)</label>
        <input id="pinAngle" type="range" min="45" max="100" value="70" />
      </div>
      <div class="row">
        <label>Pinnule Bend (%)</label>
        <input id="pinBend" type="range" min="0" max="120" value="65" />
      </div>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: branches controls -->
      <div class="row">
        <label>Branches</label>
        <input id="branchesOn" type="checkbox" />
      </div>
      <div class="row">
        <label>Branch Count</label>
        <input id="branchCount" type="range" min="0" max="12" value="4" />
      </div>
      <div class="row">
        <label>Branch Angle (°)</label>
        <input id="branchAngle" type="range" min="10" max="80" value="36" />
      </div>
      <div class="row">
        <label>Branch Length (%)</label>
        <input id="branchScale" type="range" min="20" max="120" value="60" />
      </div>
      <div class="row">
        <label>Branch Curvature</label>
        <input id="branchCurv" type="range" min="0" max="100" value="24" />
      </div>
      <div class="row">
        <label>Branch Leaf Scale (%)</label>
        <input id="branchLeafScale" type="range" min="40" max="120" value="75" />
      </div>
    </div>

    <script>
      ;(() => {
        const canvas = document.getElementById('c')
        const ctx = canvas.getContext('2d')

        // Sliders/controls
        const $leafletCount = document.getElementById('leafletCount')
        const $baseAngle = document.getElementById('baseAngle')
        const $curv = document.getElementById('curv')
        const $bend = document.getElementById('bend')
        const $taper = document.getElementById('taper')

        const $leafletCountVal = document.getElementById('leafletCountVal')
        const $baseAngleVal = document.getElementById('baseAngleVal')
        const $curvVal = document.getElementById('curvVal')
        const $bendVal = document.getElementById('bendVal')
        const $taperVal = document.getElementById('taperVal')

        const $olw = document.getElementById('olw')
        const $olc = document.getElementById('olc')
        const $fill = document.getElementById('fill')
        const $olwVal = document.getElementById('olwVal')
        const $fillVal = document.getElementById('fillVal')

        const $variety = document.getElementById('variety')
        const $transparentBg = document.getElementById('transparentBg')
        const $perspOn = document.getElementById('perspOn')
        const $persp = document.getElementById('persp')
        const $perspVal = document.getElementById('perspVal')

        // Complexity controls
        const $serrFreq = document.getElementById('serrFreq')
        const $serrAmp = document.getElementById('serrAmp')
        const $pinnulesOn = document.getElementById('pinnulesOn')
        const $pinCount = document.getElementById('pinCount')
        const $pinScale = document.getElementById('pinScale')
        const $pinAngle = document.getElementById('pinAngle')
        const $pinBend = document.getElementById('pinBend')

        // Branch controls
        const $branchesOn = document.getElementById('branchesOn')
        const $branchCount = document.getElementById('branchCount')
        const $branchAngle = document.getElementById('branchAngle')
        const $branchScale = document.getElementById('branchScale')
        const $branchCurv = document.getElementById('branchCurv')
        const $branchLeafScale = document.getElementById('branchLeafScale')

        const $toggleGrow = document.getElementById('toggleGrow')
        const $resetGrow = document.getElementById('resetGrow')
        const $gSpeed = document.getElementById('gs')
        const $gSpeedVal = document.getElementById('gsVal')
        const $gManual = document.getElementById('g')
        const $gVal = document.getElementById('gVal')

        // Canvas DPI scaling
        const dpi = () => window.devicePixelRatio || 1
        function resize() {
          const d = dpi()
          canvas.width = Math.floor(innerWidth * d)
          canvas.height = Math.floor(innerHeight * d)
          ctx.setTransform(d, 0, 0, d, 0, 0)
          // No immediate render here; tick() handles redraws
        }
        addEventListener('resize', resize)
        resize()

        // Helpers
        const deg = a => (a * Math.PI) / 180
        const lerp = (a, b, t) => a + (b - a) * t
        const clamp = (x, a, b) => Math.max(a, Math.min(b, x))
        const smoothstep = (e0, e1, x) => {
          const t = clamp((x - e0) / (e1 - e0), 0, 1)
          return t * t * (3 - 2 * t)
        }

        // Growth state
        let growth = 1 // 0..1
        let animOn = false
        let lastT = performance.now()

        function growthStep(dt) {
          if (!animOn) return
          // speed slider: 5..100 -> seconds to full growth ~ (120/speed)
          const s = Number($gSpeed.value) // higher = faster
          const rate = s / 120 // ~0.04..0.83 per second
          growth = Math.min(1, growth + rate * (dt / 1000))
          $gManual.value = Math.round(growth * 100)
          $gVal.textContent = `${Math.round(growth * 100)}%`
          if (growth >= 1) animOn = false
        }

        // Draw one symmetric leaflet using trig in local coordinates.
        function drawLeaflet(
          ctx,
          x,
          y,
          theta,
          L,
          W,
          bend,
          taperPow,
          fillRGBA,
          strokeRGBA,
          lineW,
          partial = 1,
          projector = null,
          serrFreq = 0,
          serrAmp = 0
        ) {
          // partial 0..1 scales the leaflet's revealed portion (for per-leaf growth)
          const STEPS = 28
          const revealSteps = Math.max(2, Math.floor(STEPS * partial))

          const P = projector || ((x, y) => [x, y])
          ctx.save()

          const upper = []
          const lower = []
          for (let i = 0; i <= revealSteps; i++) {
            const u = i / STEPS // full param
            const uReveal = i / revealSteps // revealed param (0..1 for drawn part)

            // Midrib bending
            const localAngle = theta + bend * Math.sin(u * Math.PI * 0.9)

            // Position along midrib
            const px = x + L * u * Math.cos(localAngle)
            const py = y + L * u * Math.sin(localAngle)

            // Width tapers by sin(pi*u)^pow with optional serration
            const baseWidth = W * Math.pow(Math.sin(Math.PI * u), taperPow)
            const serr = 1 + (serrAmp * 0.01) * Math.sin(2 * Math.PI * serrFreq * u) * Math.pow(u, 0.6)
            const width = baseWidth * serr

            // Normal
            const nx = -Math.sin(localAngle)
            const ny = Math.cos(localAngle)

            const ux = px + nx * width
            const uy = py + ny * width
            const lx = px - nx * width * 0.9
            const ly = py - ny * width * 0.9
            upper.push(P(ux, uy))
            lower.push(P(lx, ly))
          }

          // Closed shape
          ctx.beginPath()
          ctx.moveTo(upper[0][0], upper[0][1])
          for (let i = 1; i < upper.length; i++)
            ctx.lineTo(upper[i][0], upper[i][1])
          for (let i = lower.length - 1; i >= 0; i--)
            ctx.lineTo(lower[i][0], lower[i][1])
          ctx.closePath()

          ctx.fillStyle = fillRGBA
          ctx.strokeStyle = strokeRGBA
          ctx.lineWidth = lineW
          if (parseFloat(fillRGBA.split(',')[3]) > 0) ctx.fill()
          if (lineW > 0) ctx.stroke()

          // Midrib hint
          ctx.beginPath()
          const [ox, oy] = P(x, y)
          ctx.moveTo(ox, oy)
          const midX = x + L * Math.cos(theta + bend * 0.5) * partial
          const midY = y + L * Math.sin(theta + bend * 0.5) * partial
          const [mx, my] = P(midX, midY)
          ctx.lineTo(mx, my)
          ctx.strokeStyle = 'rgba(235,255,245,0.15)'
          ctx.lineWidth = Math.max(0.6, lineW * 0.6)
          ctx.stroke()

          ctx.restore()
        }

        function drawFern(ctx, opts) {
          const {
            leafletCount,
            baseAngleDeg,
            stemCurv,
            leafletBend,
            taperPowExp,
            outlineWidth,
            outlineColor,
            fillOpacity, // 0..1
            growth, // 0..1 (global growth)
            transparentBg,
            perspectiveOn,
            perspective,
            serrFreq,
            serrAmp,
            pinnulesOn,
            pinCount,
            pinScale,
            pinAngleDeg,
            pinBend,
            branchesOn,
            branchCount,
            branchAngleDeg,
            branchScale,
            branchCurv,
            branchLeafScale
          } = opts

          // Use CSS pixel coordinates; DPI is handled via context transform
          const W = innerWidth
          const H = innerHeight

          ctx.clearRect(0, 0, W, H)

          // Background vignette (unless transparent requested)
          if (!transparentBg) {
            const g = ctx.createRadialGradient(
              W * 0.5,
              H * 0.7,
              Math.min(W, H) * 0.08,
              W * 0.5,
              H * 0.7,
              Math.max(W, H) * 0.85
            )
            g.addColorStop(0, '#07130b')
            g.addColorStop(1, '#0b0f13')
            ctx.fillStyle = g
            ctx.fillRect(0, 0, W, H)
          }

          ctx.save()
          const originX = W * 0.5
          const originY = H * 0.86

          // Perspective projector (toward base/origin)
          const P = perspectiveOn && perspective > 0
            ? (x, y) => {
                const stemLen = Math.min(W, H) * 0.7
                const depth = clamp(-(y - originY) / stemLen, 0, 1)
                const k = perspective * 2
                const f = 1 / (1 + k * depth)
                const xp = originX + (x - originX) * f
                const yp = originY + (y - originY) * f
                return [xp, yp]
              }
            : null

          // Stem path (parametric)
          const stemLen = Math.min(W, H) * 0.7
          const STEPS = 200

          const stemPts = []
          for (let i = 0; i <= STEPS; i++) {
            const t = i / STEPS
            const x = +stemCurv * 0.5 * Math.sin(t * Math.PI * 0.7)
            const y = -stemLen * t * (0.9 + 0.1 * Math.cos(t * Math.PI))
            stemPts.push([x, y])
          }

          // Draw stem up to growth
          const gIdx = Math.max(1, Math.floor(STEPS * growth))
          ctx.beginPath()
          const p0 = P
            ? P(originX + stemPts[0][0], originY + stemPts[0][1])
            : [originX + stemPts[0][0], originY + stemPts[0][1]]
          ctx.moveTo(p0[0], p0[1])
          for (let i = 1; i <= gIdx; i++) {
            const xi = originX + stemPts[i][0]
            const yi = originY + stemPts[i][1]
            const pi = P ? P(xi, yi) : [xi, yi]
            ctx.lineTo(pi[0], pi[1])
          }
          ctx.strokeStyle = outlineColor
          ctx.lineWidth = Math.max(1, outlineWidth * 0.9) // stem slightly thicker than leaf outline
          ctx.stroke()

          // Tangent helper
          const tanAt = i => {
            const i0 = clamp(i - 2, 0, STEPS)
            const i1 = clamp(i + 2, 0, STEPS)
            const [x0, y0] = stemPts[i0]
            const [x1, y1] = stemPts[i1]
            return Math.atan2(y1 - y0, x1 - x0)
          }

          // Choose leaflet positions
          const firstIdx = Math.floor(STEPS * 0.08)
          const lastIdx = Math.floor(STEPS * 0.92)
          const step = Math.max(
            1,
            Math.floor((lastIdx - firstIdx) / leafletCount)
          )

          // Colors
          const fillRGBA = a => `rgba(40,125,75,${a.toFixed(3)})`

          // Collect draw items for depth sorting
          const items = []

          let side = 1
          for (let i = firstIdx; i <= lastIdx; i += step) {
            const tStem = i / STEPS

            // If the growth front hasn't reached this point, skip
            if (tStem > growth + 0.02) continue

            const [sx, sy] = stemPts[i]
            const thetaStem = tanAt(i)
            const theta = thetaStem + deg(baseAngleDeg) * side

            // Base sizes (taper along rachis)
            const baseLen =
              lerp(
                stemLen * 0.11,
                stemLen * 0.28,
                Math.cos(tStem * Math.PI) * 0.5 + 0.5
              ) *
              (0.9 - 0.15 * tStem)
            const baseWid = baseLen * 0.18

            // Per-leaf reveal factor (sprouts after stem front passes it)
            //  When growth == tStem -> start; fully grown when growth >= tStem + 0.18
            const reveal = smoothstep(0.0, 0.18, growth - tStem)

            const L = baseLen * reveal
            const Wd = baseWid * reveal
            const bend = leafletBend * (0.7 + 0.3 * (1 - tStem)) * reveal

            // Queue primary leaflet
            items.push({
              type: 'leaf',
              x: originX + sx,
              y: originY + sy,
              theta,
              L,
              W: Wd,
              bend,
              taper: taperPowExp,
              fill: fillRGBA(fillOpacity),
              stroke: outlineColor,
              lw: outlineWidth,
              partial: reveal,
              serrFreq,
              serrAmp,
              depthY: originY + sy
            })

            // Queue pinnules if enabled
            if (pinnulesOn && pinCount > 0 && L > 0) {
              for (let j = 1; j <= pinCount; j++) {
                const u = j / (pinCount + 1)
                if (u < 0.18 || u > 0.96) continue
                const localAngle = theta + bend * Math.sin(u * Math.PI * 0.9)
                const px = originX + sx + L * u * Math.cos(localAngle)
                const py = originY + sy + L * u * Math.sin(localAngle)
                const side2 = j % 2 === 0 ? 1 : -1
                const theta2 = localAngle + deg(pinAngleDeg) * side2
                const L2 = L * (pinScale / 100) * reveal
                const W2 = L2 * 0.22
                const bend2 = leafletBend * (pinBend / 100) * reveal
                items.push({
                  type: 'pinnule',
                  x: px,
                  y: py,
                  theta: theta2,
                  L: L2,
                  W: W2,
                  bend: bend2,
                  taper: Math.max(0.5, taperPowExp * 0.95),
                  fill: fillRGBA(fillOpacity),
                  stroke: outlineColor,
                  lw: Math.max(0.7, outlineWidth * 0.9),
                  partial: reveal,
                  serrFreq,
                  serrAmp,
                  depthY: py
                })
              }
            }

            side *= -1
          }

          // Branches: secondary rachises with their own leaflets
          if (branchesOn && branchCount > 0) {
            const usableStart = Math.floor(STEPS * 0.18)
            const usableEnd = Math.floor(STEPS * 0.88)
            const bStep = Math.max(1, Math.floor((usableEnd - usableStart) / branchCount))
            let bSide = 1
            for (let i = usableStart + Math.floor(bStep * 0.5); i <= usableEnd; i += bStep) {
              const tStem = i / STEPS
              const [sx, sy] = stemPts[i]
              const thetaStem = tanAt(i)
              const thetaBase = thetaStem + bSide * deg(branchAngleDeg)

              // Local frame
              const fx = Math.cos(thetaBase), fy = Math.sin(thetaBase)
              const rx = -Math.sin(thetaBase), ry = Math.cos(thetaBase)

              // Length/curvature
              const blen = Math.min(W, H) * 0.7 * (branchScale / 100) * (0.9 - 0.4 * tStem)
              const bcurvPx = Math.min(W, H) * (branchCurv / 100) * 0.18
              const B_STEPS = 120
              const bPts = []
              for (let k = 0; k <= B_STEPS; k++) {
                const tb = k / B_STEPS
                const sideSway = bcurvPx * 0.5 * Math.sin(tb * Math.PI * 0.7)
                const forward = blen * tb * (0.9 + 0.1 * Math.cos(tb * Math.PI))
                const wx = originX + sx + fx * forward + rx * sideSway
                const wy = originY + sy + fy * forward + ry * sideSway
                bPts.push([wx, wy])
              }

              // Branch growth reveal tied to main growth reaching the branch origin
              const bReveal = smoothstep(0.0, 0.25, growth - tStem)
              const gBIdx = Math.max(1, Math.floor(B_STEPS * bReveal))

              // Draw branch stem
              if (gBIdx > 1) {
                ctx.beginPath()
                const p0 = P ? P(bPts[0][0], bPts[0][1]) : bPts[0]
                ctx.moveTo(p0[0], p0[1])
                for (let k = 1; k <= gBIdx; k++) {
                  const pk = P ? P(bPts[k][0], bPts[k][1]) : bPts[k]
                  ctx.lineTo(pk[0], pk[1])
                }
                ctx.strokeStyle = outlineColor
                ctx.lineWidth = Math.max(0.9, outlineWidth * 0.85)
                ctx.stroke()
              }

              // Helpers on branch
              const tanAtB = j => {
                const j0 = clamp(j - 2, 0, B_STEPS)
                const j1 = clamp(j + 2, 0, B_STEPS)
                const [x0, y0] = bPts[j0]
                const [x1, y1] = bPts[j1]
                return Math.atan2(y1 - y0, x1 - x0)
              }

              // Leaflets along branch
              const firstB = Math.floor(B_STEPS * 0.08)
              const lastB = Math.floor(B_STEPS * 0.92)
              const stepB = Math.max(1, Math.floor((lastB - firstB) / leafletCount))
              let sideB = 1
              for (let k = firstB; k <= lastB; k += stepB) {
                const tb = k / B_STEPS
                if (tb > bReveal + 0.02) continue
                const [bx, by] = bPts[k]
                const thetaB = tanAtB(k)
                const thetaLeaf = thetaB + deg(baseAngleDeg) * sideB

                const baseLen =
                  lerp(
                    blen * 0.10,
                    blen * 0.24,
                    Math.cos(tb * Math.PI) * 0.5 + 0.5
                  ) *
                  (0.9 - 0.15 * tb) *
                  (branchLeafScale / 100)

                const revealB = smoothstep(0.0, 0.18, bReveal - tb)
                const L2 = baseLen * revealB
                const W2 = L2 * 0.18
                const bend2 = leafletBend * (0.7 + 0.3 * (1 - tb)) * revealB

                items.push({
                  type: 'branchLeaf',
                  x: bx,
                  y: by,
                  theta: thetaLeaf,
                  L: L2,
                  W: W2,
                  bend: bend2,
                  taper: taperPowExp,
                  fill: fillRGBA(fillOpacity),
                  stroke: outlineColor,
                  lw: Math.max(0.8, outlineWidth * 0.9),
                  partial: revealB,
                  serrFreq,
                  serrAmp,
                  depthY: by
                })

                sideB *= -1
              }

              bSide *= -1
            }
          }

          // Apical leaflet
          if (growth >= 0.95) {
            const tipIdx = Math.min(STEPS - 1, Math.floor(STEPS * growth))
            const [tipX, tipY] = stemPts[tipIdx]
            const thetaTip = tanAt(tipIdx)
            const tipReveal = smoothstep(0, 0.05, growth - 0.95)
            items.push({
              type: 'tip',
              x: originX + tipX,
              y: originY + tipY,
              theta: thetaTip,
              L: stemLen * 0.18 * tipReveal,
              W: stemLen * 0.035 * tipReveal,
              bend: leafletBend * 0.6 * tipReveal,
              taper: taperPowExp,
              fill: fillRGBA(fillOpacity),
              stroke: outlineColor,
              lw: outlineWidth,
              partial: tipReveal,
              serrFreq,
              serrAmp,
              depthY: originY + tipY
            })
          }

          // Depth sort (back to front by world Y)
          items.sort((a, b) => a.depthY - b.depthY)

          // Draw items
          for (const it of items) {
            if (it.L <= 0 || it.W <= 0) continue
            drawLeaflet(
              ctx,
              it.x,
              it.y,
              it.theta,
              it.L,
              it.W,
              it.bend,
              it.taper,
              it.fill,
              it.stroke,
              it.lw,
              it.partial,
              P,
              serrFreq,
              serrAmp
            )
          }

          ctx.restore()
        }

        function getOpts() {
          // update readouts
          const o = {
            leafletCount: Number($leafletCount.value),
            baseAngleDeg: Number($baseAngle.value),
            stemCurv:
              Math.min(innerWidth, innerHeight) *
              (Number($curv.value) / 100) *
              0.25,
            leafletBend: (Number($bend.value) / 100) * Math.PI * 0.35,
            taperPowExp: Math.max(0.5, Number($taper.value) / 100),
            outlineWidth: Number($olw.value),
            outlineColor: $olc.value.replace('#', '#'), // hex -> canvas will handle
            fillOpacity: Number($fill.value) / 100,
            growth: growth,
            transparentBg: $transparentBg.checked,
            perspectiveOn: $perspOn.checked,
            perspective: Number($persp.value) / 100,
            serrFreq: Number($serrFreq ? $serrFreq.value : 0),
            serrAmp: Number($serrAmp ? $serrAmp.value : 0),
            pinnulesOn: $pinnulesOn ? $pinnulesOn.checked : false,
            pinCount: Number($pinCount ? $pinCount.value : 0),
            pinScale: Number($pinScale ? $pinScale.value : 28),
            pinAngleDeg: Number($pinAngle ? $pinAngle.value : 70),
            pinBend: Number($pinBend ? $pinBend.value : 65),
            branchesOn: $branchesOn ? $branchesOn.checked : false,
            branchCount: Number($branchCount ? $branchCount.value : 0),
            branchAngleDeg: Number($branchAngle ? $branchAngle.value : 36),
            branchScale: Number($branchScale ? $branchScale.value : 60),
            branchCurv: Number($branchCurv ? $branchCurv.value : 24),
            branchLeafScale: Number($branchLeafScale ? $branchLeafScale.value : 75)
          }

          // labels
          $leafletCountVal.textContent = o.leafletCount
          $baseAngleVal.textContent = o.baseAngleDeg + '°'
          $curvVal.textContent = (Number($curv.value) / 100).toFixed(2)
          $bendVal.textContent = (Number($bend.value) / 100).toFixed(2)
          $taperVal.textContent = (Number($taper.value) / 100).toFixed(2)

          $olwVal.textContent = o.outlineWidth.toFixed(1)
          $fillVal.textContent = o.fillOpacity.toFixed(2)
          $gSpeedVal.textContent = Number($gSpeed.value)
          $gVal.textContent = Math.round(growth * 100) + '%'
          $perspVal.textContent = Number($persp.value)

          return o
        }

        function render() {
          drawFern(ctx, getOpts())
        }

        // Animation loop
        function tick(t) {
          const dt = t - lastT
          lastT = t
          growthStep(dt)
          render()
          requestAnimationFrame(tick)
        }
        requestAnimationFrame(tick)

        // Variety presets
        const VARIETIES = {
          bracken: {
            leafletCount: 28,
            baseAngle: 48,
            curv: 42,
            bend: 22,
            taper: 140,
            olw: 1.2,
            fill: 60
          },
          maidenhair: {
            leafletCount: 46,
            baseAngle: 24,
            curv: 18,
            bend: 18,
            taper: 90,
            olw: 0.8,
            fill: 45
          },
          boston: {
            leafletCount: 38,
            baseAngle: 34,
            curv: 30,
            bend: 30,
            taper: 110,
            olw: 1.0,
            fill: 55
          },
          staghorn: {
            leafletCount: 22,
            baseAngle: 56,
            curv: 22,
            bend: 14,
            taper: 75,
            olw: 1.1,
            fill: 50
          },
          ostrich: {
            leafletCount: 34,
            baseAngle: 18,
            curv: 8,
            bend: 20,
            taper: 130,
            olw: 1.1,
            fill: 58
          }
        }

        function applyVariety(name) {
          const v = VARIETIES[name]
          if (!v) return
          $leafletCount.value = String(v.leafletCount)
          $baseAngle.value = String(v.baseAngle)
          $curv.value = String(v.curv)
          $bend.value = String(v.bend)
          $taper.value = String(v.taper)
          $olw.value = String(v.olw)
          $fill.value = String(v.fill)
          render()
        }

        // Wire up UI
        ;[
          $leafletCount,
          $baseAngle,
          $curv,
          $bend,
          $taper,
          $olw,
          $olc,
          $fill,
          $gManual,
          $gSpeed,
          $serrFreq,
          $serrAmp,
          $pinnulesOn,
          $pinCount,
          $pinScale,
          $pinAngle,
          $pinBend,
          $branchesOn,
          $branchCount,
          $branchAngle,
          $branchScale,
          $branchCurv,
          $branchLeafScale
        ].filter(Boolean).forEach(el => {
          el.addEventListener('input', () => {
            if (el === $gManual) {
              growth = Number($gManual.value) / 100
            }
            // Any manual change sets variety to custom
            if ($variety.value !== 'custom') $variety.value = 'custom'
            render()
          })
        })

        $variety.addEventListener('change', () => {
          if ($variety.value === 'custom') return render()
          // Auto-reset and animate on preset select
          growth = 0
          $gManual.value = 0
          animOn = true
          $toggleGrow.textContent = '⏸ Pause'
          applyVariety($variety.value)
        })

        $transparentBg.addEventListener('change', render)
        $perspOn.addEventListener('change', render)
        $persp.addEventListener('input', () => {
          if ($variety.value !== 'custom') $variety.value = 'custom'
          render()
        })

        $toggleGrow.addEventListener('click', () => {
          animOn = !animOn
          $toggleGrow.textContent = animOn ? '⏸ Pause' : '▶ Grow'
        })

        $resetGrow.addEventListener('click', () => {
          growth = 0
          $gManual.value = 0
          animOn = false
          $toggleGrow.textContent = '▶ Grow'
          render()
        })

        addEventListener('keydown', e => {
          if (e.key.toLowerCase() === 'g') {
            animOn = !animOn
            $toggleGrow.textContent = animOn ? '⏸ Pause' : '▶ Grow'
          }
        })
      })()
    </script>
  </body>
</html>
