<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Canvas Fern — Trig + Growth + Outline Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0b0f13;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      .ui {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 2;
        font: 14px/1.35 system-ui, sans-serif;
        color: #d8f5df;
        background: rgba(10, 15, 20, 0.55);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(140, 200, 160, 0.25);
        border-radius: 12px;
        padding: 12px;
        width: 300px;
        max-height: 92vh;
        overflow: auto;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
      }
      .row label {
        flex: 1 1 auto;
      }
      .row input[type='range'] {
        width: 120px;
      }
      .row input[type='color'] {
        width: 40px;
        height: 24px;
        padding: 0;
        border: none;
        background: transparent;
      }
      .btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid rgba(150, 220, 180, 0.3);
        background: rgba(12, 20, 16, 0.6);
        color: #d8f5df;
        cursor: pointer;
      }
      .btn:active {
        transform: translateY(1px);
      }
      small {
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <div class="ui">
      <strong style="display: block; margin-bottom: 6px">Fern Controls</strong>

      <div class="row">
        <label>Leaflets <small id="leafletCountVal"></small></label
        ><input id="leafletCount" type="range" min="16" max="64" value="36" />
      </div>
      <div class="row">
        <label>Base Angle (°) <small id="baseAngleVal"></small></label
        ><input id="baseAngle" type="range" min="10" max="58" value="34" />
      </div>
      <div class="row">
        <label>Stem Curvature <small id="curvVal"></small></label
        ><input id="curv" type="range" min="0" max="100" value="36" />
      </div>
      <div class="row">
        <label>Leaflet Bend <small id="bendVal"></small></label
        ><input id="bend" type="range" min="0" max="100" value="28" />
      </div>
      <div class="row">
        <label>Taper Power <small id="taperVal"></small></label
        ><input id="taper" type="range" min="60" max="200" value="110" />
      </div>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: outline controls -->
      <div class="row">
        <label>Outline Width (px) <small id="olwVal"></small></label>
        <input id="olw" type="range" min="0" max="4" step="0.1" value="1" />
      </div>
      <div class="row">
        <label>Outline Color</label>
        <input id="olc" type="color" value="#00ff66" />
      </div>
      <div class="row">
        <label>Fill Opacity <small id="fillVal"></small></label>
        <input id="fill" type="range" min="0" max="100" value="55" />
      </div>

      <hr style="border-color: rgba(160, 220, 170, 0.25)" />

      <!-- NEW: growth controls -->
      <div class="row">
        <button id="toggleGrow" class="btn">▶ Grow</button>
        <button id="resetGrow" class="btn">⟲ Reset</button>
      </div>
      <div class="row">
        <label>Growth Speed <small id="gsVal"></small></label>
        <input id="gs" type="range" min="5" max="100" value="28" />
      </div>
      <div class="row">
        <label>Growth (manual) <small id="gVal"></small></label>
        <input id="g" type="range" min="0" max="100" value="100" />
      </div>
      <small>Tip: Press <b>G</b> to toggle growth animation.</small>
    </div>

    <script>
      ;(() => {
        const canvas = document.getElementById('c')
        const ctx = canvas.getContext('2d')

        // Sliders/controls
        const $leafletCount = document.getElementById('leafletCount')
        const $baseAngle = document.getElementById('baseAngle')
        const $curv = document.getElementById('curv')
        const $bend = document.getElementById('bend')
        const $taper = document.getElementById('taper')

        const $leafletCountVal = document.getElementById('leafletCountVal')
        const $baseAngleVal = document.getElementById('baseAngleVal')
        const $curvVal = document.getElementById('curvVal')
        const $bendVal = document.getElementById('bendVal')
        const $taperVal = document.getElementById('taperVal')

        const $olw = document.getElementById('olw')
        const $olc = document.getElementById('olc')
        const $fill = document.getElementById('fill')
        const $olwVal = document.getElementById('olwVal')
        const $fillVal = document.getElementById('fillVal')

        const $toggleGrow = document.getElementById('toggleGrow')
        const $resetGrow = document.getElementById('resetGrow')
        const $gSpeed = document.getElementById('gs')
        const $gSpeedVal = document.getElementById('gsVal')
        const $gManual = document.getElementById('g')
        const $gVal = document.getElementById('gVal')

        // Canvas DPI scaling
        const dpi = () => window.devicePixelRatio || 1
        function resize() {
          const d = dpi()
          canvas.width = Math.floor(innerWidth * d)
          canvas.height = Math.floor(innerHeight * d)
          ctx.setTransform(d, 0, 0, d, 0, 0)
          // No immediate render here; tick() handles redraws
        }
        addEventListener('resize', resize)
        resize()

        // Helpers
        const deg = a => (a * Math.PI) / 180
        const lerp = (a, b, t) => a + (b - a) * t
        const clamp = (x, a, b) => Math.max(a, Math.min(b, x))
        const smoothstep = (e0, e1, x) => {
          const t = clamp((x - e0) / (e1 - e0), 0, 1)
          return t * t * (3 - 2 * t)
        }

        // Growth state
        let growth = 1 // 0..1
        let animOn = false
        let lastT = performance.now()

        function growthStep(dt) {
          if (!animOn) return
          // speed slider: 5..100 -> seconds to full growth ~ (120/speed)
          const s = Number($gSpeed.value) // higher = faster
          const rate = s / 120 // ~0.04..0.83 per second
          growth = Math.min(1, growth + rate * (dt / 1000))
          $gManual.value = Math.round(growth * 100)
          $gVal.textContent = `${Math.round(growth * 100)}%`
          if (growth >= 1) animOn = false
        }

        // Draw one symmetric leaflet using trig in local coordinates.
        function drawLeaflet(
          ctx,
          x,
          y,
          theta,
          L,
          W,
          bend,
          taperPow,
          fillRGBA,
          strokeRGBA,
          lineW,
          partial = 1
        ) {
          // partial 0..1 scales the leaflet's revealed portion (for per-leaf growth)
          const STEPS = 28
          const revealSteps = Math.max(2, Math.floor(STEPS * partial))

          ctx.save()
          ctx.translate(x, y)

          const upper = []
          const lower = []
          for (let i = 0; i <= revealSteps; i++) {
            const u = i / STEPS // full param
            const uReveal = i / revealSteps // revealed param (0..1 for drawn part)

            // Midrib bending
            const localAngle = theta + bend * Math.sin(u * Math.PI * 0.9)

            // Position along midrib
            const px = L * u * Math.cos(localAngle)
            const py = L * u * Math.sin(localAngle)

            // Width tapers by sin(pi*u)^pow
            const width = W * Math.pow(Math.sin(Math.PI * u), taperPow)

            // Normal
            const nx = -Math.sin(localAngle)
            const ny = Math.cos(localAngle)

            upper.push([px + nx * width, py + ny * width])
            lower.push([px - nx * width * 0.9, py - ny * width * 0.9])
          }

          // Closed shape
          ctx.beginPath()
          ctx.moveTo(upper[0][0], upper[0][1])
          for (let i = 1; i < upper.length; i++)
            ctx.lineTo(upper[i][0], upper[i][1])
          for (let i = lower.length - 1; i >= 0; i--)
            ctx.lineTo(lower[i][0], lower[i][1])
          ctx.closePath()

          ctx.fillStyle = fillRGBA
          ctx.strokeStyle = strokeRGBA
          ctx.lineWidth = lineW
          if (parseFloat(fillRGBA.split(',')[3]) > 0) ctx.fill()
          if (lineW > 0) ctx.stroke()

          // Midrib hint
          ctx.beginPath()
          ctx.moveTo(0, 0)
          const midX = L * Math.cos(theta + bend * 0.5) * partial
          const midY = L * Math.sin(theta + bend * 0.5) * partial
          ctx.lineTo(midX, midY)
          ctx.strokeStyle = 'rgba(235,255,245,0.15)'
          ctx.lineWidth = Math.max(0.6, lineW * 0.6)
          ctx.stroke()

          ctx.restore()
        }

        function drawFern(ctx, opts) {
          const {
            leafletCount,
            baseAngleDeg,
            stemCurv,
            leafletBend,
            taperPowExp,
            outlineWidth,
            outlineColor,
            fillOpacity, // 0..1
            growth // 0..1 (global growth)
          } = opts

          // Use CSS pixel coordinates; DPI is handled via context transform
          const W = innerWidth
          const H = innerHeight

          ctx.clearRect(0, 0, W, H)

          // Background vignette
          const g = ctx.createRadialGradient(
            W * 0.5,
            H * 0.7,
            Math.min(W, H) * 0.08,
            W * 0.5,
            H * 0.7,
            Math.max(W, H) * 0.85
          )
          g.addColorStop(0, '#07130b')
          g.addColorStop(1, '#0b0f13')
          ctx.fillStyle = g
          ctx.fillRect(0, 0, W, H)

          ctx.save()
          const originX = W * 0.5
          const originY = H * 0.86
          ctx.translate(originX, originY)

          // Stem path (parametric)
          const stemLen = Math.min(W, H) * 0.7
          const STEPS = 200

          const stemPts = []
          for (let i = 0; i <= STEPS; i++) {
            const t = i / STEPS
            const x = +stemCurv * 0.5 * Math.sin(t * Math.PI * 0.7)
            const y = -stemLen * t * (0.9 + 0.1 * Math.cos(t * Math.PI))
            stemPts.push([x, y])
          }

          // Draw stem up to growth
          const gIdx = Math.max(1, Math.floor(STEPS * growth))
          ctx.beginPath()
          ctx.moveTo(stemPts[0][0], stemPts[0][1])
          for (let i = 1; i <= gIdx; i++)
            ctx.lineTo(stemPts[i][0], stemPts[i][1])
          ctx.strokeStyle = outlineColor
          ctx.lineWidth = Math.max(1, outlineWidth * 0.9) // stem slightly thicker than leaf outline
          ctx.stroke()

          // Tangent helper
          const tanAt = i => {
            const i0 = clamp(i - 2, 0, STEPS)
            const i1 = clamp(i + 2, 0, STEPS)
            const [x0, y0] = stemPts[i0]
            const [x1, y1] = stemPts[i1]
            return Math.atan2(y1 - y0, x1 - x0)
          }

          // Choose leaflet positions
          const firstIdx = Math.floor(STEPS * 0.08)
          const lastIdx = Math.floor(STEPS * 0.92)
          const step = Math.max(
            1,
            Math.floor((lastIdx - firstIdx) / leafletCount)
          )

          // Colors
          const fillRGBA = a => `rgba(40,125,75,${a.toFixed(3)})`

          let side = 1
          for (let i = firstIdx; i <= lastIdx; i += step) {
            const tStem = i / STEPS

            // If the growth front hasn't reached this point, skip
            if (tStem > growth + 0.02) continue

            const [sx, sy] = stemPts[i]
            const thetaStem = tanAt(i)
            const theta = thetaStem + deg(baseAngleDeg) * side

            // Base sizes (taper along rachis)
            const baseLen =
              lerp(
                stemLen * 0.11,
                stemLen * 0.28,
                Math.cos(tStem * Math.PI) * 0.5 + 0.5
              ) *
              (0.9 - 0.15 * tStem)
            const baseWid = baseLen * 0.18

            // Per-leaf reveal factor (sprouts after stem front passes it)
            //  When growth == tStem -> start; fully grown when growth >= tStem + 0.18
            const reveal = smoothstep(0.0, 0.18, growth - tStem)

            const L = baseLen * reveal
            const Wd = baseWid * reveal
            const bend = leafletBend * (0.7 + 0.3 * (1 - tStem)) * reveal

            drawLeaflet(
              ctx,
              sx,
              sy,
              theta,
              L,
              Wd,
              bend,
              taperPowExp,
              fillRGBA(fillOpacity),
              outlineColor,
              outlineWidth,
              reveal // partial draw along midrib
            )

            side *= -1
          }

          // Apical leaflet
          if (growth >= 0.95) {
            const tipIdx = Math.min(STEPS - 1, Math.floor(STEPS * growth))
            const [tipX, tipY] = stemPts[tipIdx]
            const thetaTip = tanAt(tipIdx)
            const tipReveal = smoothstep(0, 0.05, growth - 0.95)
            drawLeaflet(
              ctx,
              tipX,
              tipY,
              thetaTip,
              stemLen * 0.18 * tipReveal,
              stemLen * 0.035 * tipReveal,
              leafletBend * 0.6 * tipReveal,
              taperPowExp,
              fillRGBA(fillOpacity),
              outlineColor,
              outlineWidth,
              tipReveal
            )
          }

          ctx.restore()
        }

        function getOpts() {
          // update readouts
          const o = {
            leafletCount: Number($leafletCount.value),
            baseAngleDeg: Number($baseAngle.value),
            stemCurv:
              Math.min(innerWidth, innerHeight) *
              (Number($curv.value) / 100) *
              0.25,
            leafletBend: (Number($bend.value) / 100) * Math.PI * 0.35,
            taperPowExp: Math.max(0.5, Number($taper.value) / 100),
            outlineWidth: Number($olw.value),
            outlineColor: $olc.value.replace('#', '#'), // hex -> canvas will handle
            fillOpacity: Number($fill.value) / 100,
            growth: growth
          }

          // labels
          $leafletCountVal.textContent = o.leafletCount
          $baseAngleVal.textContent = o.baseAngleDeg + '°'
          $curvVal.textContent = (Number($curv.value) / 100).toFixed(2)
          $bendVal.textContent = (Number($bend.value) / 100).toFixed(2)
          $taperVal.textContent = (Number($taper.value) / 100).toFixed(2)

          $olwVal.textContent = o.outlineWidth.toFixed(1)
          $fillVal.textContent = o.fillOpacity.toFixed(2)
          $gSpeedVal.textContent = Number($gSpeed.value)
          $gVal.textContent = Math.round(growth * 100) + '%'

          return o
        }

        function render() {
          drawFern(ctx, getOpts())
        }

        // Animation loop
        function tick(t) {
          const dt = t - lastT
          lastT = t
          growthStep(dt)
          render()
          requestAnimationFrame(tick)
        }
        requestAnimationFrame(tick)

        // Wire up UI
        ;[
          $leafletCount,
          $baseAngle,
          $curv,
          $bend,
          $taper,
          $olw,
          $olc,
          $fill,
          $gManual,
          $gSpeed
        ].forEach(el => {
          el.addEventListener('input', () => {
            if (el === $gManual) {
              growth = Number($gManual.value) / 100
            }
            render()
          })
        })

        $toggleGrow.addEventListener('click', () => {
          animOn = !animOn
          $toggleGrow.textContent = animOn ? '⏸ Pause' : '▶ Grow'
        })

        $resetGrow.addEventListener('click', () => {
          growth = 0
          $gManual.value = 0
          animOn = false
          $toggleGrow.textContent = '▶ Grow'
          render()
        })

        addEventListener('keydown', e => {
          if (e.key.toLowerCase() === 'g') {
            animOn = !animOn
            $toggleGrow.textContent = animOn ? '⏸ Pause' : '▶ Grow'
          }
        })
      })()
    </script>
  </body>
</html>
