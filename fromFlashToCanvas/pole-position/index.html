<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Pole‑Position Style — Canvas Vector Racer</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
        color: #cfe8ff;
        font-family: system-ui, sans-serif;
      }
      #split {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: 1fr 1fr;
      }
      .pane { position: relative; overflow: hidden; }
      .pane canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        user-select: none;
      }
      #hud {
        position: fixed;
        left: 10px;
        top: 10px;
        z-index: 2;
        font-size: 13px;
        background: rgba(15, 22, 34, 0.85);
        border: 1px solid rgba(140, 200, 255, 0.35);
        border-radius: 10px;
        padding: 8px 10px;
        backdrop-filter: blur(6px);
      }
      #help {
        position: fixed;
        left: 10px;
        bottom: 10px;
        font-size: 12px;
        opacity: 0.85;
      }
    </style>
  </head>
  <body>
    <div id="split">
      <div class="pane"><canvas id="game"></canvas></div>
      <div class="pane"><canvas id="side"></canvas></div>
    </div>
    <div id="hud">
      Lap: <span id="lap">1</span> • Time: <span id="time">0.0</span>s • Speed:
      <span id="spd">0</span> • PosX: <span id="pos">0</span>
    </div>
    <div id="help">
      Controls: ←/→ steer • ↑ accel • ↓ brake • Drag to steer • Double‑tap to
      boost • R restart
    </div>
    <script>
      ;(() => {
        const cv = document.getElementById('game')
        const ctx = cv.getContext('2d')
        const side = document.getElementById('side')
        const sctx = side.getContext('2d')
        const dpr = Math.max(1, window.devicePixelRatio || 1)
        // Road config (declared early so resize can reference it)
        let road = { minHalf: 24 * dpr, maxHalf: 0, rumble: 6 * dpr }

        let W = 0,
          H = 0
        let horizonY = 0
        let SW = 0, SH = 0
        function resize() {
          const cssW = cv.clientWidth || (window.innerWidth/2)
          const cssH = cv.clientHeight || window.innerHeight
          cv.width = Math.floor(cssW * dpr)
          cv.height = Math.floor(cssH * dpr)
          // side canvas (right)
          side.width = Math.floor((side.clientWidth || (window.innerWidth/2)) * dpr)
          side.height = Math.floor((side.clientHeight || window.innerHeight) * dpr)
          W = cv.width
          H = cv.height
          SW = side.width
          SH = side.height
          horizonY = Math.floor(H * 0.44)
          // keep road width responsive
          road.maxHalf = W * 0.35
        }
        window.addEventListener('resize', resize)
        resize()

        const u = {
          lap: byId('lap'),
          time: byId('time'),
          spd: byId('spd'),
          pos: byId('pos')
        }
        function byId(id) {
          return document.getElementById(id)
        }

        // Game state
        const player = {
          x: 0, // lateral (-1..1)
          dx: 0,
          carW: 40 * dpr,
          carH: 70 * dpr,
          maxSpeed: 360 * dpr,
          speed: 0,
          accel: 220 * dpr,
          brake: 350 * dpr,
          friction: 110 * dpr
        }
        const track = { length: 16000, t: 0, lap: 1, timeMs: 0 }

        // --- Track curve: simple periodic sum of sines (continuous loop) ---
        function trackCurve(z){
          const k = 1/1200
          return (
            Math.sin(z*k*1.2)*0.8 +
            Math.sin(z*k*0.5 + 1.7)*0.5 +
            Math.sin(z*k*2.4 + 3.2)*0.25
          )
        }

        // No vertical hills for clean vector look
        function trackHill(z) { return 0 }

        // No AI/obstacles — single car

        // Input
        const keys = { left: false, right: false, up: false, down: false }
        let requestBoost = false
        let touchActive = false,
          lastTapT = 0,
          lastTapX = 0,
          lastTapY = 0
        window.addEventListener('keydown', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true
          else if (e.code === 'ArrowRight' || e.code === 'KeyD')
            keys.right = true
          else if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true
          else if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true
          else if (e.code === 'KeyR') reset()
        })
        window.addEventListener('keyup', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false
          else if (e.code === 'ArrowRight' || e.code === 'KeyD')
            keys.right = false
          else if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false
          else if (e.code === 'ArrowDown' || e.code === 'KeyS')
            keys.down = false
        })
        function getPointerOn(el, e) {
          const r = el.getBoundingClientRect()
          return { x: (e.clientX - r.left) * dpr, y: (e.clientY - r.top) * dpr }
        }
        cv.addEventListener(
          'pointerdown',
          e => {
            e.preventDefault()
            cv.setPointerCapture(e.pointerId)
            const p = getPointerOn(cv, e)
            const dt = e.timeStamp - lastTapT,
              dx = p.x - lastTapX,
              dy = p.y - lastTapY
            if (dt > 0 && dt < 300 && dx * dx + dy * dy < 42 * 42 * dpr * dpr)
              requestBoost = true
            lastTapT = e.timeStamp
            lastTapX = p.x
            lastTapY = p.y
            touchActive = true
            steerToPointer(p.x)
          },
          { passive: false }
        )
        cv.addEventListener('pointermove', e => {
          if (!touchActive) return
          steerToPointer(getPointerOn(cv, e).x)
        })
        function endTouch(e) {
          try {
            cv.releasePointerCapture(e.pointerId)
          } catch (_) {}
          touchActive = false
        }
        cv.addEventListener('pointerup', endTouch)
        cv.addEventListener('pointercancel', endTouch)
        function steerToPointer(px) {
          const center = W / 2
          const rel = (px - center) / (W * 0.42)
          player.dx = rel * 1.7
        }

        function reset() {
          track.t = 0
          track.lap = 1
          track.timeMs = 0
          player.speed = 0
          player.x = 0
          // nothing else to reset
        }

        // Projection helpers
        function roadHalfAtY(screenY) {
          const t = Math.max(
            0,
            Math.min(1, (screenY - horizonY) / (H - horizonY))
          )
          return road.minHalf + (road.maxHalf - road.minHalf) * t
        }
        function depthForY(screenY) {
          const t = Math.max(
            0.0001,
            Math.min(1, (screenY - horizonY) / (H - horizonY))
          )
          return t * 1200 // how far ahead this band represents
        }

        function drawScene(dt) {
          // Clear background (monochrome)
          ctx.fillStyle = '#000'
          ctx.fillRect(0, 0, W, H)
          // Horizon line
          ctx.strokeStyle = '#cfe8ff'
          ctx.lineWidth = 1 * dpr
          ctx.beginPath(); ctx.moveTo(0, horizonY); ctx.lineTo(W, horizonY); ctx.stroke()

          // Vector road edges and centerline
          const bandH = Math.max(2, Math.floor(3 * dpr))
          const leftPts = []
          const rightPts = []
          const centerPts = []
          for (let y = horizonY; y <= H; y += bandH) {
            const z = depthForY(y) - track.t
            const curve = trackCurve(z)
            const centerX = W / 2 - curve * 220 * dpr - player.x * 140 * dpr
            const half = roadHalfAtY(y)
            leftPts.push([centerX - half, y])
            rightPts.push([centerX + half, y])
            centerPts.push([centerX, y])
          }
          ctx.strokeStyle = '#cfe8ff'
          ctx.lineWidth = 2 * dpr
          // left edge
          ctx.beginPath(); for (let i=0;i<leftPts.length;i++){ const p=leftPts[i]; (i? ctx.lineTo(p[0],p[1]) : ctx.moveTo(p[0],p[1])) } ctx.stroke()
          // right edge
          ctx.beginPath(); for (let i=0;i<rightPts.length;i++){ const p=rightPts[i]; (i? ctx.lineTo(p[0],p[1]) : ctx.moveTo(p[0],p[1])) } ctx.stroke()
          // center dashed line
          ctx.save(); ctx.setLineDash([10*dpr, 10*dpr]); ctx.beginPath(); for (let i=0;i<centerPts.length;i++){ const p=centerPts[i]; (i? ctx.lineTo(p[0],p[1]) : ctx.moveTo(p[0],p[1])) } ctx.stroke(); ctx.restore()
        }

        // Right pane: side/minimap view (monochrome vector)
        function drawSide(){
          sctx.clearRect(0,0,SW,SH)
          sctx.fillStyle = '#000'
          sctx.fillRect(0,0,SW,SH)
          // center guide
          sctx.strokeStyle = '#1b2a3a'
          sctx.lineWidth = 1*dpr
          sctx.beginPath(); sctx.moveTo(SW/2, 0); sctx.lineTo(SW/2, SH); sctx.stroke()
          // sample one full lap starting at current position
          const steps = 360
          const half = SW*0.18
          const scaleX = SW*0.38 // lateral scale
          sctx.strokeStyle = '#cfe8ff'
          sctx.lineWidth = 2*dpr
          // centerline
          sctx.setLineDash([10*dpr, 10*dpr])
          sctx.beginPath()
          for (let i=0;i<=steps;i++){
            const t = i/steps
            const z = track.t + t*track.length
            const x = SW/2 - trackCurve(z)*scaleX - player.x*scaleX*0.6
            const y = t*SH
            if (i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y)
          }
          sctx.stroke(); sctx.setLineDash([])
          // edges
          sctx.beginPath()
          for (let i=0;i<=steps;i++){
            const t = i/steps
            const z = track.t + t*track.length
            const x = SW/2 - trackCurve(z)*scaleX - player.x*scaleX*0.6
            const y = t*SH
            if (i===0) sctx.moveTo(x-half,y); else sctx.lineTo(x-half,y)
          }
          sctx.stroke()
          sctx.beginPath()
          for (let i=0;i<=steps;i++){
            const t = i/steps
            const z = track.t + t*track.length
            const x = SW/2 - trackCurve(z)*scaleX - player.x*scaleX*0.6
            const y = t*SH
            if (i===0) sctx.moveTo(x+half,y); else sctx.lineTo(x+half,y)
          }
          sctx.stroke()
          // car marker at top
          const sz = 8*dpr
          sctx.fillStyle = '#cfe8ff'
          sctx.beginPath(); sctx.moveTo(SW/2, 6*dpr); sctx.lineTo(SW/2 - sz*0.7, 6*dpr + sz); sctx.lineTo(SW/2 + sz*0.7, 6*dpr + sz); sctx.closePath(); sctx.fill()
        }

        // Game loop
        let last = performance.now()
        function step() {
          const now = performance.now()
          let dt = now - last
          if (dt > 80) dt = 80
          last = now
          track.timeMs += dt
          // speed control
          if (keys.up || requestBoost)
            player.speed = Math.min(
              player.maxSpeed,
              player.speed + player.accel * (dt / 1000)
            )
          else if (keys.down)
            player.speed = Math.max(
              0,
              player.speed - player.brake * (dt / 1000)
            )
          else
            player.speed = Math.max(
              0,
              player.speed - player.friction * (dt / 1000)
            )
          requestBoost = false

          // steering
          const steer = (keys.left ? -1 : 0) + (keys.right ? 1 : 0)
          player.x = Math.max(
            -1,
            Math.min(1, player.x + (player.dx + steer * 0.02))
          )
          player.dx *= 0.9

          // advance along track
          track.t += player.speed * (dt / 1000)
          if (track.t >= track.length) {
            track.t -= track.length
            track.lap += 1
          }

          // UI
          u.lap.textContent = track.lap
          u.time.textContent = (track.timeMs / 1000).toFixed(1)
          u.spd.textContent = (player.speed / dpr) | 0
          u.pos.textContent = player.x.toFixed(2)
        }

        function loop() {
          step()
          drawScene(16)
          drawSide()
          requestAnimationFrame(loop)
        }
        loop()
      })()
    </script>
  </body>
</html>
