<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sudoku ‚Äî 4-up Printable (Canvas)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --page-width: 8.5in;
    --page-height: 11in;
  }
  html, body {
    margin: 0;
    padding: 0;
    background: #ffffff; /* print friendly */
    color: #000;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }

  /* Center a letter-sized sheet in the page for screen preview */
  .page {
    width: var(--page-width);
    min-height: var(--page-height);
    margin: 0 auto;
    box-sizing: border-box;
    padding: 0.5in;           /* page margin */
    display: flex;
    flex-direction: column;
    gap: 0.4in;
  }

  #controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
  }
  #controls button {
    appearance: none;
    border: 1px solid #777;
    background: #f5f5f5;
    padding: 0.5rem 0.9rem;
    cursor: pointer;
    border-radius: 6px;
    font-size: 0.95rem;
  }
  #controls button:hover { background:#eee; }

  .grid4 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-auto-rows: 1fr;
    gap: 0.35in; /* spacing between puzzles */
    align-items: center;
    justify-items: center;
  }

  .puzzle-wrap {
    width: 3.6in;   /* each puzzle visual size for nice 2x2 on Letter */
    height: 3.6in;
    display: grid;
    place-items: center;
  }

  canvas {
    width: 100%;
    height: 100%;
    /* The backing bitmap is set via JS to keep crisp lines */
    background: #fff;
    display: block;
  }

  /* Ensure perfect print: centered, letter size, no extra headers/footers */
  @page {
    size: letter portrait;
    margin: 0.5in; /* printer margin */
  }
  @media print {
    #controls { display: none !important; }
    body, html { background: #fff; }
    .page {
      width: auto;
      min-height: auto;
      margin: 0;
      padding: 0;
    }
    .grid4 {
      gap: 0.35in;
      page-break-inside: avoid;
    }
    .puzzle-wrap {
      break-inside: avoid;
    }
  }
</style>
</head>
<body>

<div class="page">
  <div id="controls">
    <button id="genBtn" title="Generate 4 new random Sudoku">üîÄ Generate New Puzzles</button>
    <button id="printBtn" title="Print the 4 puzzles">üñ®Ô∏è Print</button>
  </div>

  <div class="grid4" id="grid4">
    <div class="puzzle-wrap"><canvas class="puzzle" width="960" height="960"></canvas></div>
    <div class="puzzle-wrap"><canvas class="puzzle" width="960" height="960"></canvas></div>
    <div class="puzzle-wrap"><canvas class="puzzle" width="960" height="960"></canvas></div>
    <div class="puzzle-wrap"><canvas class="puzzle" width="960" height="960"></canvas></div>
  </div>
</div>

<script>
/*
  Sudoku Generator & Renderer (Canvas)
  - Generates full valid boards with backtracking
  - Removes clues in symmetric pairs while ensuring UNIQUE solution (solution counter)
  - Draws to canvas with 20px inner margin, grey lines, bold 3x3 borders
  - 4 puzzles per page, 2x2 grid
*/

(function(){
  // ------ Utility ------
  function shuffled(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function deepCopyBoard(board) {
    return board.map(row => row.slice());
  }

  // ------ Sudoku Core ------
  const SIZE = 9;
  const BOX = 3;
  const DIGITS = [1,2,3,4,5,6,7,8,9];

  function isValid(board, r, c, val) {
    // Row & col
    for (let i = 0; i < SIZE; i++) {
      if (board[r][i] === val) return false;
      if (board[i][c] === val) return false;
    }
    // Box
    const br = Math.floor(r/BOX)*BOX;
    const bc = Math.floor(c/BOX)*BOX;
    for (let i = 0; i < BOX; i++) {
      for (let j = 0; j < BOX; j++) {
        if (board[br+i][bc+j] === val) return false;
      }
    }
    return true;
  }

  function findEmpty(board) {
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (board[r][c] === 0) return [r, c];
      }
    }
    return null;
  }

  function solve(board){
    const spot = findEmpty(board);
    if (!spot) return true;
    const [r, c] = spot;

    for (const n of shuffled(DIGITS)) {
      if (isValid(board, r, c, n)) {
        board[r][c] = n;
        if (solve(board)) return true;
        board[r][c] = 0;
      }
    }
    return false;
  }

  function countSolutions(board, limit=2) {
    // backtracking that counts up to `limit` solutions
    let count = 0;
    function backtrack() {
      if (count >= limit) return; // early stop
      const spot = findEmpty(board);
      if (!spot) { count++; return; }
      const [r, c] = spot;
      for (const n of DIGITS) {
        if (isValid(board, r, c, n)) {
          board[r][c] = n;
          backtrack();
          board[r][c] = 0;
          if (count >= limit) return;
        }
      }
    }
    backtrack();
    return count;
  }

  function generateFullSolution() {
    const board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    // Fill diagonal 3x3 boxes first to make solving faster
    for (let d = 0; d < SIZE; d += BOX) {
      const nums = shuffled(DIGITS);
      let k = 0;
      for (let i = 0; i < BOX; i++) {
        for (let j = 0; j < BOX; j++) {
          board[d+i][d+j] = nums[k++];
        }
      }
    }
    // Solve the rest
    solve(board);
    return board;
  }

  // Remove clues symmetrically while ensuring unique solution
  function makePuzzleFromSolution(solution, targetClues = 30) {
    const puzzle = deepCopyBoard(solution);
    // Build cell index list (only half due to symmetry)
    const cells = [];
    for (let idx = 0; idx < 81; idx++) {
      const r = Math.floor(idx / 9);
      const c = idx % 9;
      const symIdx = 80 - idx; // 180-degree symmetry
      if (idx <= symIdx) cells.push([idx, symIdx]);
    }
    const order = shuffled(cells);

    let clues = 81;
    for (const [a, b] of order) {
      if (clues <= targetClues) break;
      const ar = Math.floor(a / 9), ac = a % 9;
      const br = Math.floor(b / 9), bc = b % 9;

      const prevA = puzzle[ar][ac];
      const prevB = puzzle[br][bc];

      if (prevA === 0 && prevB === 0) continue;

      // Try removing both
      puzzle[ar][ac] = 0;
      if (a !== b) puzzle[br][bc] = 0;

      // Check unique
      const copy = deepCopyBoard(puzzle);
      const solCount = countSolutions(copy, 2);

      if (solCount === 1) {
        clues -= (a === b) ? 1 : 2;
      } else {
        // Revert
        puzzle[ar][ac] = prevA;
        if (a !== b) puzzle[br][bc] = prevB;
      }
    }
    return puzzle;
  }

  function generateUniquePuzzle(targetClues=30, maxRetries=5) {
    // Occasionally the removal phase may get stuck > target; retry with a new solution
    for (let i = 0; i < maxRetries; i++) {
      const sol = generateFullSolution();
      const puzzle = makePuzzleFromSolution(sol, targetClues);
      // Ensure final uniqueness for safety
      const copy = deepCopyBoard(puzzle);
      if (countSolutions(copy, 2) === 1) {
        return { puzzle, solution: sol };
      }
    }
    // Fallback: still return the last attempt (should be unique in practice)
    const sol = generateFullSolution();
    return { puzzle: makePuzzleFromSolution(sol, targetClues), solution: sol };
  }

  // ------ Canvas Drawing ------
  function drawSudoku(canvas, puzzle) {
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Clear
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, W, H);

    // 20px inner margin
    const M = 20;
    const size = Math.min(W, H) - 2*M;
    const cell = size / 9;
    const x0 = (W - size)/2;
    const y0 = (H - size)/2;

    // Grid (light grey thin lines)
    ctx.strokeStyle = '#bbb';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= 9; i++) {
      const x = x0 + i*cell;
      const y = y0 + i*cell;
      // vertical
      ctx.moveTo(x + 0.5, y0);
      ctx.lineTo(x + 0.5, y0 + size);
      // horizontal
      ctx.moveTo(x0, y + 0.5);
      ctx.lineTo(x0 + size, y + 0.5);
    }
    ctx.stroke();

    // Bold 3x3 borders (darker)
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= 9; i += 3) {
      const x = x0 + i*cell;
      const y = y0 + i*cell;
      // vertical
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0 + size);
      // horizontal
      ctx.moveTo(x0, y);
      ctx.lineTo(x0 + size, y);
    }
    ctx.stroke();

    // Numbers
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${Math.floor(cell*0.55)}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;

    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const val = puzzle[r][c];
        if (val) {
          const cx = x0 + c*cell + cell/2;
          const cy = y0 + r*cell + cell/2;
          ctx.fillText(String(val), cx, cy + 1);
        }
      }
    }
  }

  // ------ Orchestration ------
  const canvases = Array.from(document.querySelectorAll('canvas.puzzle'));
  const genBtn = document.getElementById('genBtn');
  const printBtn = document.getElementById('printBtn');

  async function generateFour() {
    genBtn.disabled = true;
    genBtn.textContent = 'Generating‚Ä¶';
    try {
      // Target clues ~28‚Äì34 yields varied difficulty; 30 is a nice middle.
      const targets = [30, 32, 28, 34];
      const puzzles = [];

      // Generate sequentially to avoid blocking too long at once
      for (let i = 0; i < 4; i++) {
        // Yield to UI between heavy steps
        await new Promise(r => setTimeout(r, 0));
        const { puzzle } = generateUniquePuzzle(targets[i], 6);
        puzzles.push(puzzle);
      }
      // Render
      for (let i = 0; i < 4; i++) drawSudoku(canvases[i], puzzles[i]);
    } finally {
      genBtn.disabled = false;
      genBtn.textContent = 'üîÄ Generate New Puzzles';
    }
  }

  genBtn.addEventListener('click', generateFour);
  printBtn.addEventListener('click', () => window.print());

  // First render on load
  generateFour();
})();
</script>
</body>
</html>
