<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RedefineIt ‚Äî Vector Fields + Magnetic Attractor</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b0f13;
        --ui-bg: rgba(10, 15, 24, 0.55);
        --ui-bd: rgba(120, 160, 220, 0.28);
        --text: #d9e7ff;
        --accent: #70d6ff;
        --accent2: #d57cff;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        overflow: hidden;
        font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      /* UI */
      .ui {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 5;
        width: 320px;
        max-height: min(92vh, 840px);
        padding: 12px;
        border-radius: 14px;
        color: var(--text);
        background: var(--ui-bg);
        backdrop-filter: blur(8px);
        border: 1px solid var(--ui-bd);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }
      .ui h2 {
        margin: 0 0 8px;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.3px;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 8px 0;
      }
      .row label {
        flex: 1 1 auto;
        font-size: 12px;
        opacity: 0.9;
      }
      .row input[type='range'],
      .row select {
        flex: 1 1 55%;
        accent-color: #8ac8ff;
      }
      .small {
        font-size: 11px;
        opacity: 0.8;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--ui-bd);
        background: rgba(255, 255, 255, 0.04);
        padding: 6px 10px;
        border-radius: 10px;
        color: var(--text);
        cursor: pointer;
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.08);
      }
      .group {
        border-top: 1px solid rgba(120, 160, 220, 0.18);
        margin: 10px -12px 0;
        padding: 10px 12px 0;
      }
      .toggles {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .toggle {
        display: flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--ui-bd);
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.04);
      }
      .toggle input {
        margin: 0;
      }
      /* üëÅÔ∏è eye */
      .eye {
        position: fixed;
        right: 14px;
        top: 14px;
        z-index: 6;
        font-size: 14px;
        color: var(--text);
        background: var(--ui-bg);
        border: 1px solid var(--ui-bd);
        border-radius: 999px;
        padding: 8px 12px;
        cursor: pointer;
        user-select: none;
      }
      .eye:hover {
        background: rgba(255, 255, 255, 0.08);
      }
      .tip {
        position: fixed;
        right: 14px;
        bottom: 14px;
        color: #9fb7ff;
        font-size: 11px;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="eye" id="eye" title="Show/Hide Controls">üëÅÔ∏è Toggle UI (U)</div>
    <div class="tip">
      Drag on canvas to move the attractor ‚Ä¢ Shift+Drag to set a repeller ‚Ä¢
      Double‚Äëclick to center
    </div>
    <div class="ui" id="ui">
      <h2>Vector Field ‚Äî Magnetic Attractor</h2>
      <div class="row">
        <label for="preset">Preset</label>
        <select id="preset">
          <option value="custom">Custom</option>
          <option value="calm-swirl">Calm Swirl</option>
          <option value="storm-vortex">Storm Vortex</option>
          <option value="ripples">Ripples</option>
          <option value="saddle">Saddle Flux</option>
        </select>
      </div>

      <div class="row">
        <label>Grid Density <span class="small" id="gridNOut"></span></label
        ><input id="gridN" type="range" min="12" max="64" step="1" value="36" />
      </div>
      <div class="row">
        <label>Line Thickness</label
        ><input
          id="thick"
          type="range"
          min="0.5"
          max="2.5"
          step="0.1"
          value="1.1"
        />
      </div>
      <div class="row">
        <label>Glow (px)</label
        ><input id="glow" type="range" min="0" max="16" step="1" value="8" />
      </div>
      <div class="row">
        <label>Hue</label
        ><input id="hue" type="range" min="0" max="360" step="1" value="200" />
      </div>

      <div class="group">
        <div class="row">
          <label>Base Field</label>
          <select id="fieldType">
            <option value="curl">Curl (sin/cos)</option>
            <option value="swirl">Swirl</option>
            <option value="saddle">Saddle</option>
            <option value="radial">Radial</option>
            <option value="perp">Perpendicular Flow</option>
          </select>
        </div>
        <div class="row">
          <label>Field Strength</label
          ><input
            id="fieldK"
            type="range"
            min="0"
            max="2"
            step="0.01"
            value="0.65"
          />
        </div>
        <div class="row">
          <label>Field Frequency</label
          ><input
            id="freq"
            type="range"
            min="0.2"
            max="4"
            step="0.01"
            value="1.4"
          />
        </div>
        <div class="row">
          <label>Time Speed</label
          ><input
            id="speed"
            type="range"
            min="0"
            max="2"
            step="0.01"
            value="0.6"
          />
        </div>
      </div>

      <div class="group">
        <div class="row">
          <label>Magnetic Strength</label
          ><input
            id="magK"
            type="range"
            min="-3"
            max="3"
            step="0.01"
            value="1.2"
          />
        </div>
        <div class="row">
          <label>Falloff (Exponent)</label
          ><input
            id="fall"
            type="range"
            min="0.4"
            max="3.5"
            step="0.01"
            value="1.6"
          />
        </div>
        <div class="row">
          <label>Spin (Vortex)</label
          ><input
            id="spin"
            type="range"
            min="-3"
            max="3"
            step="0.01"
            value="0.75"
          />
        </div>
        <div class="toggles">
          <label class="toggle"
            ><input id="repel" type="checkbox" />Repel</label
          >
          <label class="toggle"
            ><input id="lock" type="checkbox" />Lock Attractor</label
          >
          <button class="btn" id="centerBtn" type="button">
            Center Attractor
          </button>
        </div>
      </div>

      <div class="group">
        <div class="toggles">
          <label class="toggle"
            ><input id="showArrows" type="checkbox" />Arrows</label
          >
          <label class="toggle"
            ><input id="showPoints" type="checkbox" checked />Points</label
          >
          <label class="toggle"
            ><input id="animate" type="checkbox" checked />Animate</label
          >
          <label class="toggle"
            ><input id="warpGrid" type="checkbox" checked />Warp Grid</label
          >
        </div>
      </div>

      <div class="row" style="justify-content: space-between">
        <button class="btn" id="copyUrl" type="button">Copy State URL</button>
        <button class="btn" id="randomize" type="button">Randomize</button>
      </div>
    </div>

    <script>
      ;(() => {
        const canvas = document.getElementById('c')
        const dpr = Math.max(1, devicePixelRatio || 1)
        const ctx = canvas.getContext('2d')
        let W = 0,
          H = 0,
          t = 0,
          running = true

        // UI elements
        const $ = id => document.getElementById(id)
        const uiEls = {
          gridN: $('gridN'),
          thick: $('thick'),
          glow: $('glow'),
          hue: $('hue'),
          fieldType: $('fieldType'),
          fieldK: $('fieldK'),
          freq: $('freq'),
          speed: $('speed'),
          magK: $('magK'),
          fall: $('fall'),
          spin: $('spin'),
          repel: $('repel'),
          lock: $('lock'),
          showArrows: $('showArrows'),
          showPoints: $('showPoints'),
          animate: $('animate'),
          warpGrid: $('warpGrid'),
          preset: $('preset')
        }
        const gridNOut = $('gridNOut')

        const state = {
          gridN: +uiEls.gridN.value,
          thick: +uiEls.thick.value,
          glow: +uiEls.glow.value,
          hue: +uiEls.hue.value,
          fieldType: uiEls.fieldType.value,
          fieldK: +uiEls.fieldK.value,
          freq: +uiEls.freq.value,
          speed: +uiEls.speed.value,
          magK: +uiEls.magK.value,
          fall: +uiEls.fall.value,
          spin: +uiEls.spin.value,
          repel: uiEls.repel.checked,
          lock: uiEls.lock.checked,
          showArrows: uiEls.showArrows.checked,
          showPoints: uiEls.showPoints.checked,
          animate: uiEls.animate.checked,
          warpGrid: uiEls.warpGrid.checked,
          ax: 0.5,
          ay: 0.5 // attractor in NDC
        }

        const presets = {
          'calm-swirl': {
            fieldType: 'curl',
            fieldK: 0.5,
            freq: 1.1,
            speed: 0.5,
            magK: 0.75,
            fall: 1.4,
            spin: 0.4,
            repel: false,
            gridN: 32,
            glow: 10,
            hue: 205
          },
          'storm-vortex': {
            fieldType: 'swirl',
            fieldK: 1.3,
            freq: 2.0,
            speed: 1.1,
            magK: 2.2,
            fall: 0.95,
            spin: 1.8,
            repel: false,
            gridN: 40,
            glow: 14,
            hue: 285
          },
          ripples: {
            fieldType: 'radial',
            fieldK: 0.7,
            freq: 2.8,
            speed: 0.8,
            magK: 0.6,
            fall: 2.0,
            spin: 0.0,
            repel: false,
            gridN: 36,
            glow: 8,
            hue: 170
          },
          saddle: {
            fieldType: 'saddle',
            fieldK: 1.0,
            freq: 1.4,
            speed: 0.7,
            magK: 1.4,
            fall: 1.3,
            spin: -0.6,
            repel: true,
            gridN: 44,
            glow: 12,
            hue: 24
          }
        }

        function applyPreset(name) {
          if (!presets[name]) return
          const p = presets[name]
          Object.assign(state, p)
          // push to UI
          for (const k in p) {
            if (uiEls[k] !== undefined) {
              const el = uiEls[k]
              if (el.type === 'checkbox') el.checked = p[k]
              else el.value = p[k]
            }
          }
          uiEls.gridN.value = p.gridN
          uiEls.hue.value = p.hue
          uiEls.glow.value = p.glow
          uiEls.fieldType.value = p.fieldType
          needRemesh = true
        }

        uiEls.preset.addEventListener('change', e => {
          if (e.target.value !== 'custom') {
            applyPreset(e.target.value)
            pushHash()
          }
        })

        // Bind UI
        for (const [k, el] of Object.entries(uiEls)) {
          if (k === 'preset') continue
          el.addEventListener('input', () => {
            state[k] =
              el.type === 'checkbox'
                ? el.checked
                : el.type === 'range' || el.tagName === 'SELECT'
                ? el.type === 'range'
                  ? +el.value
                  : el.value
                : el.value
            if (k === 'gridN') needRemesh = true
            gridNOut.textContent = `(${state.gridN}√ó${state.gridN})`
            if (k === 'animate') running = state.animate
            if (['fieldType'].includes(k)) needRemesh = true
            pushHash()
          })
        }

        function resize() {
          const { clientWidth: w, clientHeight: h } = canvas
          if (w === W && h === H) return
          W = w
          H = h
          canvas.width = Math.floor(W * dpr)
          canvas.height = Math.floor(H * dpr)
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
          needRemesh = true
        }
        addEventListener('resize', resize, { passive: true })
        resize()

        // Grid mesh
        let needRemesh = true
        let grid = [] // array of points {x,y}

        function remesh() {
          grid = []
          const n = Math.max(6, Math.floor(state.gridN))
          const pad = 30
          const xmin = pad,
            xmax = W - pad
          const ymin = pad,
            ymax = H - pad
          for (let j = 0; j < n; j++) {
            const y = ymin + (ymax - ymin) * (j / (n - 1))
            const row = []
            for (let i = 0; i < n; i++) {
              const x = xmin + (xmax - xmin) * (i / (n - 1))
              row.push({ x, y })
            }
            grid.push(row)
          }
          needRemesh = false
        }

        // Vector fields
        function vecField(x, y, tt) {
          // Normalize to [-1,1]
          const nx = (x / W) * 2 - 1
          const ny = (y / H) * 2 - 1
          const f = state.freq
          let vx = 0,
            vy = 0

          switch (state.fieldType) {
            case 'curl':
              vx += Math.sin(f * ny + tt)
              vy += Math.cos(f * nx - tt)
              break
            case 'swirl': {
              const r2 = nx * nx + ny * ny + 1e-6
              vx += -ny / r2 // tangential
              vy += nx / r2
              break
            }
            case 'saddle':
              vx += nx
              vy += -ny
              break
            case 'radial': {
              const r = Math.hypot(nx, ny) + 1e-6
              vx += (nx / r) * Math.sin(f * r * 3 - tt)
              vy += (ny / r) * Math.sin(f * r * 3 - tt)
              break
            }
            case 'perp':
              vx += ny * Math.cos(tt * 0.7)
              vy += -nx * Math.sin(tt * 0.7)
              break
          }

          // Magnetic attractor / repeller with optional spin
          const ax = state.ax * W,
            ay = state.ay * H
          const dx = x - ax,
            dy = y - ay
          const r = Math.hypot(dx, dy) + 1e-6
          const dirx = dx / r,
            diry = dy / r
          const sgn = state.repel ? 1 : -1 // repel flips sign
          const fall = Math.max(0.01, state.fall)

          // radial (attract/repel)
          vx += (sgn * state.magK * dirx) / Math.pow(r / 220 + 0.001, fall)
          vy += (sgn * state.magK * diry) / Math.pow(r / 220 + 0.001, fall)

          // tangential spin (vortex)
          const svx =
            (-diry * state.spin) / Math.pow(r / 220 + 0.001, fall * 0.9)
          const svy =
            (dirx * state.spin) / Math.pow(r / 220 + 0.001, fall * 0.9)
          vx += svx
          vy += svy

          // scale base field
          vx *= state.fieldK
          vy *= state.fieldK

          return [vx, vy]
        }

        function draw() {
          if (needRemesh) remesh()
          const thick = state.thick
          ctx.clearRect(0, 0, W, H)

          // Subtle vignette background
          const g = ctx.createRadialGradient(
            W * 0.5,
            H * 0.5,
            Math.min(W, H) * 0.1,
            W * 0.5,
            H * 0.5,
            Math.max(W, H) * 0.8
          )
          g.addColorStop(0, '#0b0f13')
          g.addColorStop(1, '#04070c')
          ctx.fillStyle = g
          ctx.fillRect(0, 0, W, H)

          const hue = state.hue | 0
          const glow = state.glow | 0
          ctx.lineWidth = thick
          ctx.lineCap = 'round'
          ctx.lineJoin = 'round'
          ctx.strokeStyle = `hsl(${hue} 80% 70% / .95)`
          ctx.fillStyle = `hsl(${hue} 90% 80% / .85)`
          if (glow > 0) {
            ctx.shadowBlur = glow
            ctx.shadowColor = `hsl(${hue} 100% 65%)`
          } else {
            ctx.shadowBlur = 0
          }

          // Sample displacement per grid point
          const tt = t * state.speed

          // Draw warped grid lines
          const n = grid.length
          const amp = 18 // displacement scale

          function displaced(p) {
            const [vx, vy] = vecField(p.x, p.y, tt)
            return { x: p.x + vx * amp, y: p.y + vy * amp }
          }

          // Horizontal lines
          for (let j = 0; j < n; j++) {
            ctx.beginPath()
            let first = true
            for (let i = 0; i < n; i++) {
              const p = state.warpGrid ? displaced(grid[j][i]) : grid[j][i]
              if (first) {
                ctx.moveTo(p.x, p.y)
                first = false
              } else ctx.lineTo(p.x, p.y)
            }
            ctx.stroke()
          }
          // Vertical lines
          for (let i = 0; i < n; i++) {
            ctx.beginPath()
            let first = true
            for (let j = 0; j < n; j++) {
              const p = state.warpGrid ? displaced(grid[j][i]) : grid[j][i]
              if (first) {
                ctx.moveTo(p.x, p.y)
                first = false
              } else ctx.lineTo(p.x, p.y)
            }
            ctx.stroke()
          }

          // Field points / arrows for reference
          if (state.showPoints || state.showArrows) {
            const step = Math.max(10, Math.floor(n / 2))
            for (let j = 0; j < n; j += Math.ceil(n / step)) {
              for (let i = 0; i < n; i += Math.ceil(n / step)) {
                const p = grid[j][i]
                const [vx, vy] = vecField(p.x, p.y, tt)
                const px = p.x + vx * amp
                const py = p.y + vy * amp
                if (state.showPoints) {
                  ctx.beginPath()
                  ctx.arc(px, py, 1.6 + thick * 0.2, 0, Math.PI * 2)
                  ctx.fill()
                }
                if (state.showArrows) {
                  drawArrow(p.x, p.y, px, py)
                }
              }
            }
          }

          // Attractor marker
          const ax = state.ax * W,
            ay = state.ay * H
          ctx.save()
          ctx.shadowBlur = 16
          ctx.shadowColor = `hsl(${hue} 100% 70%)`
          ctx.strokeStyle = `hsl(${hue} 100% 78% / .9)`
          ctx.lineWidth = 1.4
          ctx.beginPath()
          ctx.arc(ax, ay, 8, 0, Math.PI * 2)
          ctx.moveTo(ax - 12, ay)
          ctx.lineTo(ax + 12, ay)
          ctx.moveTo(ax, ay - 12)
          ctx.lineTo(ax, ay + 12)
          ctx.stroke()
          ctx.restore()
        }

        function drawArrow(x0, y0, x1, y1) {
          const dx = x1 - x0,
            dy = y1 - y0
          const L = Math.hypot(dx, dy) + 1e-6
          const ux = dx / L,
            uy = dy / L
          const size = 6
          const bx = x1 - ux * size,
            by = y1 - uy * size
          ctx.beginPath()
          ctx.moveTo(x0, y0)
          ctx.lineTo(x1, y1)
          ctx.stroke()
          ctx.beginPath()
          ctx.moveTo(x1, y1)
          ctx.lineTo(bx - uy * size * 0.6, by + ux * size * 0.6)
          ctx.lineTo(bx + uy * size * 0.6, by - ux * size * 0.6)
          ctx.closePath()
          ctx.fill()
        }

        function loop(ts) {
          if (state.animate) t = ts * 0.001 // seconds
          draw()
          requestAnimationFrame(loop)
        }
        requestAnimationFrame(loop)

        // Interactions: drag attractor
        let dragging = false
        canvas.addEventListener('pointerdown', e => {
          if (state.lock) return
          dragging = true
          setAttractorFromEvent(e, e.shiftKey) // shift toggles repel
        })
        canvas.addEventListener('pointermove', e => {
          if (!dragging || state.lock) return
          setAttractorFromEvent(e, e.shiftKey)
        })
        addEventListener('pointerup', () => (dragging = false))
        addEventListener('pointercancel', () => (dragging = false))
        canvas.addEventListener('dblclick', () => {
          state.ax = 0.5
          state.ay = 0.5
          pushHash()
        })

        function setAttractorFromEvent(e, holdRepel) {
          const rect = canvas.getBoundingClientRect()
          state.ax = (e.clientX - rect.left) / rect.width
          state.ay = (e.clientY - rect.top) / rect.height
          if (holdRepel) {
            uiEls.repel.checked = true
            state.repel = true
          }
          pushHash()
        }

        // Center button
        $('centerBtn').addEventListener('click', () => {
          state.ax = 0.5
          state.ay = 0.5
          pushHash()
        })

        // Eye toggle & keyboard
        const eye = document.getElementById('eye')
        const panel = document.getElementById('ui')
        function toggleUI() {
          panel.style.display =
            panel.style.display === 'none' ? 'block' : 'none'
        }
        eye.addEventListener('click', toggleUI)
        addEventListener('keydown', e => {
          if (e.key.toLowerCase() === 'u') toggleUI()
        })

        // Randomize
        $('randomize').addEventListener('click', () => {
          const pick = arr => arr[Math.floor(Math.random() * arr.length)]
          state.fieldType = pick(['curl', 'swirl', 'saddle', 'radial', 'perp'])
          uiEls.fieldType.value = state.fieldType
          state.fieldK = +(Math.random() * 1.6).toFixed(2)
          uiEls.fieldK.value = state.fieldK
          state.freq = +(0.2 + Math.random() * 3.5).toFixed(2)
          uiEls.freq.value = state.freq
          state.speed = +(Math.random() * 1.4).toFixed(2)
          uiEls.speed.value = state.speed
          state.magK = +((-1 + Math.random() * 2) * 2.5).toFixed(2)
          uiEls.magK.value = state.magK
          uiEls.repel.checked = state.magK > 0
          state.repel = state.magK > 0
          state.fall = +(0.5 + Math.random() * 3).toFixed(2)
          uiEls.fall.value = state.fall
          state.spin = +((-1 + Math.random() * 2) * 2.4).toFixed(2)
          uiEls.spin.value = state.spin
          state.gridN = Math.floor(18 + Math.random() * 34)
          uiEls.gridN.value = state.gridN
          needRemesh = true
          state.glow = Math.floor(Math.random() * 16)
          uiEls.glow.value = state.glow
          state.hue = Math.floor(Math.random() * 360)
          uiEls.hue.value = state.hue
          state.ax = Math.random()
          state.ay = Math.random()
          pushHash()
        })

        // Shareable URL state (hash)
        function pushHash() {
          const o = { ...state }
          // don't include large or derived values
          const json = encodeURIComponent(JSON.stringify(o))
          history.replaceState(null, '', location.pathname + '#' + json)
        }
        function loadHash() {
          if (location.hash.length > 1) {
            try {
              const o = JSON.parse(decodeURIComponent(location.hash.slice(1)))
              Object.assign(state, o)
              for (const [k, v] of Object.entries(o)) {
                const el = uiEls[k]
                if (!el) continue
                if (el.type === 'checkbox') el.checked = !!v
                else el.value = v
              }
              needRemesh = true
              uiEls.preset.value = 'custom'
            } catch (e) {
              /* ignore */
            }
          }
        }
        loadHash()
        gridNOut.textContent = `(${state.gridN}√ó${state.gridN})`

        $('copyUrl').addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(location.href)
            eye.textContent = '‚úÖ Copied URL'
            setTimeout(() => (eye.textContent = 'üëÅÔ∏è Toggle UI (U)'), 900)
          } catch (err) {
            alert('Copy failed.')
          }
        })
      })()
    </script>
  </body>
</html>
